settitle ()
{
    # This function is used to change the title of the current xterm window.
    # The terminal's title also depends upon the PS1 prompt, but I don't quite
    # know how.

    local title="$1";
    if [ -z $title ]
    then
        echo "Enter a title for this terminal window: ";
        read title;
    fi

    echo -ne "\033]0;$title\007"

    # ESC]0;stringBEL -- Set icon name and window title to string
    # ESC]1;stringBEL -- Set icon name to string
    # ESC]2;stringBEL -- Set window title to string

    # where ESC is the escape character (\033),
    # and BEL is the bell character (\007).
    # (source: http://tldp.org/HOWTO/Xterm-Title-3.html)
}

extract () {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)  tar xjf $1 ;; #&& cd $(basename "$1" .tar.bz2) ;;
            *.tar.gz)   tar xzf $1 ;; #&& cd $(basename "$1" .tar.gz) ;;
            *.tar.xz)   tar xJf $1 ;; #&& cd $(basename "$1" .tar.xz) ;;
            *.bz2)      bunzip2 $1 ;; #&& cd $(basename "$1" /bz2) ;;
            *.rar)      unrar x $1 ;; #&& cd $(basename "$1" .rar) ;;
            *.gz)       gunzip $1 ;; #&& cd $(basename "$1" .gz) ;;
            *.tar)      tar xvf $1 ;; #&& cd $(basename "$1" .tar) ;;
            *.tbz2)     tar xjf $1 ;; #&& cd $(basename "$1" .tbz2) ;;
            *.tgz)      tar xzf $1 ;; #&& cd $(basename "$1" .tgz) ;;
            *.zip)      unzip $1 ;; #&& cd $(basename "$1" .zip) ;;
            *.Z)        uncompress $1 ;; #&& cd $(basename "$1" .Z) ;;
            *.7z)       7z x $1 ;; #&& cd $(basename "$1" .7z) ;;
            *)          echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

dns_servers()
{
    # to list DNS servers associated with all interfaces, use:
    #    $> dns_server
    # to list DNS servers associated with a specific interface, use:
    #    $> dns_server eth0

    # There's a segmentation fault observed with 'eth0' with NetworkManager 0.9.8.0
    # should be fixed in NetworkManager 0.9.8.4
    # use 'NetworkManager --version' to check version

    if [ -z $1 ]; then
        for interface in `ip link show | sed -n 's/^.*:\s\(.*\):.*$/\1/p'`
        do
            echo "$interface:"
            nmcli dev list iface $interface > /dev/null 2>&1
            if [ $? = "0" ]; then
                nmcli dev list iface $interface | grep DNS | awk '{print "    " $NF}'
            else
                echo "    <None>"
            fi
            echo ""
        done
    else
        interface=$1
        echo "$interface:"
        nmcli dev list iface $interface > /dev/null 2>&1
        if [ $? = "0" ]; then
            nmcli dev list iface $interface | grep DNS | awk '{print "    " $NF}'
        else
            echo "    <None>"
        fi
    fi
}

dec()
{
    if [[ $1 == 0x* ]]; then
        printf "%d\n" $1
    else
        printf "%d\n" 0x$1
    fi
}

hex()
{
    printf "0x%X\n" $1
}

stopwatch_interrupt()
{
    echo -ne "\rstopwatch complete: $(date -u --date @$((`date +%s` - $date1)) +%H:%M:%S)\n"
    exit 0
}

stopwatch()
{
    (
        date1=`date +%s`

        echo -e "Press Ctrl-C to stop, Enter to split"

        trap stopwatch_interrupt SIGINT

        while true
        do
            echo -ne "$(date -u --date @$((`date +%s` - $date1)) +%H:%M:%S)\r"
            sleep 0.1
        done
    )
}

show_line()
{
    LINE_NUM="$1"
    FILE="$2"

    if [ "$LINE_NUM" -le 0 ]
    then
        echo "Invalid line number '$LINE_NUM'"
        return
    fi

    SED_CMD="$LINE_NUM"p

    sed -n $SED_CMD $FILE
}

del_line()
{
    if [ $# -eq 0 ]
    then
        echo "Usage: del_line <line_num> <file>"
        return
    fi

    LINE_NUM="$1"
    FILE="$2"

    if [ "$LINE_NUM" -le 0 ]
    then
        echo "Invalid line number '$LINE_NUM'"
        return
    fi

    SED_CMD="$LINE_NUM"d

    LINE_TO_DELETE=$(show_line $LINE_NUM $FILE)

    sed -i $SED_CMD $FILE

    echo "Deleted line:"
    echo $LINE_TO_DELETE
}

# Open vim at a specific line, and place the line at the top of the editor
# Usage:
#     $> vl <file-name> [<line-number>]
vl()
{
    if [ $# -eq 0 ]; then
        echo "Usage: vl <file-name> [<line-number>]"
        return
    fi

    FILE="$1"
    LINE_NUM="$2"

    vim +${LINE_NUM} ${FILE} -c 'normal zt'
}

# Notes:
# The current value of IFS (Internal Field Separator) may be viewed using the following pipeline:
#
# $> echo "$IFS" | od -b
# 0000000 040 011 012 012
# 0000004
# $>
#
# The output of the echo command is piped into the octal dump command, giving you its octal
# equivalent. You can then use an ASCII table to determine what characters are stored in the
# variable.
# Hint: Ignore the first set of zeros and the second newline character (012), which was generated by
# echo.
# (source: http://www.livefirelabs.com/unix_tip_trick_shell_script/oct_2003/10132003.htm)
